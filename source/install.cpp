#include "common.hpp"

Service g_esSrv;
u64 g_esRefCnt;
Service g_nsAppManSrv, g_nsGetterSrv;
u64 g_nsRefCnt;

Result esInitialize(void)
{
    atomicIncrement64(&g_esRefCnt);
    Result rc = smGetService(&g_esSrv, "es");
    return rc;
}

void esExit(void)
{
    if (atomicDecrement64(&g_esRefCnt) == 0)
    {
        serviceClose(&g_esSrv);
    }
}

static Result _nsGetInterface(Service *srv_out, u64 cmd_id)
{
    IpcCommand c;
    ipcInitialize(&c);

    struct RAW
    {
        u64 magic;
        u64 cmd_id;
    } * raw;

    raw = (struct RAW *)ipcPrepareHeader(&c, sizeof(*raw));

    raw->magic = SFCI_MAGIC;
    raw->cmd_id = cmd_id;

    Result rc = serviceIpcDispatch(&g_nsGetterSrv);

    if (R_SUCCEEDED(rc))
    {
        IpcParsedCommand r;
        ipcParse(&r);

        struct RESP
        {
            u64 magic;
            u64 result;
        } *resp = (struct RESP *)r.Raw;

        rc = resp->result;

        if (R_SUCCEEDED(rc))
        {
            serviceCreate(srv_out, r.Handles[0]);
        }
    }

    return rc;
}

Result nsextInitialize(void)
{
    Result rc = 0;

    atomicIncrement64(&g_nsRefCnt);

    if (serviceIsActive(&g_nsGetterSrv) || serviceIsActive(&g_nsAppManSrv))
        return 0;

    if (!kernelAbove300())
        return smGetService(&g_nsAppManSrv, "ns:am");

    rc = smGetService(&g_nsGetterSrv, "ns:am2"); //TODO: Support the other services?(Only useful when ns:am2 isn't accessible)
    if (R_FAILED(rc))
        return rc;

    rc = _nsGetInterface(&g_nsAppManSrv, 7996);

    if (R_FAILED(rc))
        serviceClose(&g_nsGetterSrv);

    return rc;
}

void nsextExit(void)
{
    if (atomicDecrement64(&g_nsRefCnt) == 0)
    {
        serviceClose(&g_nsAppManSrv);
        if (!kernelAbove300())
            return;

        serviceClose(&g_nsGetterSrv);
    }
}

Result esImportTicket(void const *tikBuf, size_t tikSize, void const *certBuf, size_t certSize)
{
    IpcCommand c;
    ipcInitialize(&c);
    ipcAddSendBuffer(&c, tikBuf, tikSize, BufferType_Normal);
    ipcAddSendBuffer(&c, certBuf, certSize, BufferType_Normal);

    struct RAW
    {
        u64 magic;
        u64 cmd_id;
    } * raw;

    raw = (struct RAW *)ipcPrepareHeader(&c, sizeof(*raw));
    raw->magic = SFCI_MAGIC;
    raw->cmd_id = 1;

    Result rc = serviceIpcDispatch(&g_esSrv);

    if (R_SUCCEEDED(rc))
    {
        IpcParsedCommand r;
        ipcParse(&r);

        struct RESP
        {
            u64 magic;
            u64 result;
        } *resp = (struct RESP *)r.Raw;

        rc = resp->result;
    }

    return rc;
}

Result nsDownloadApplication(u64 tid, u32 unk, u8 storageId)
{
    IpcCommand c;
    ipcInitialize(&c);

    struct RAW
    {
        u64 magic;
        u64 cmd_id;
        u32 storageId;
        u32 unk;
        u64 tid;
    } * raw;

    raw = (struct RAW *)ipcPrepareHeader(&c, sizeof(*raw));

    raw->magic = SFCI_MAGIC;
    raw->cmd_id = 82;
    raw->storageId = storageId;
    raw->unk = unk;
    raw->tid = tid;

    Result rc = serviceIpcDispatch(&g_nsAppManSrv);

    if (R_SUCCEEDED(rc))
    {
        IpcParsedCommand r;
        ipcParse(&r);

        struct RESP
        {
            u64 magic;
            u64 result;
        } *resp = (struct RESP *)r.Raw;

        rc = resp->result;
    }

    return rc;
}

unsigned long int byteswap(unsigned long int x)
{
    x = (x & 0x00000000FFFFFFFF) << 32 | (x & 0xFFFFFFFF00000000) >> 32;
    x = (x & 0x0000FFFF0000FFFF) << 16 | (x & 0xFFFF0000FFFF0000) >> 16;
    x = (x & 0x00FF00FF00FF00FF) << 8 | (x & 0xFF00FF00FF00FF00) >> 8;
    return x;
}

Result installTikCert(u64 tid, u8 mkey, u64 tkeyh, u64 tkeyl)
{
    tid = byteswap(tid);
    tkeyh = byteswap(tkeyh);
    tkeyl = byteswap(tkeyl);

    static const string cert =
        "00010003704138EFBBBDA16A987DD901326D1C9459484C88A2861B91A312587AE70EF6237EC50E1032DC39DDE89A96A8E859D76A98A6E7E36A0CFE352CA89305"  //000-03F
        "8234FF833FCB3B03811E9F0DC0D9A52F8045B4B2F9411B67A51C44B5EF8CE77BD6D56BA75734A1856DE6D4BED6D3A242C7C8791B3422375E5C779ABF072F7695"  //040-07F
        "EFA0F75BCB83789FC30E3FE4CC8392207840638949C7F688565F649B74D63D8D58FFADDA571E9554426B1318FC468983D4C8A5628B06B6FC5D507C13E7A18AC1"  //080-0BF
        "511EB6D62EA5448F83501447A9AFB3ECC2903C9DD52F922AC9ACDBEF58C6021848D96E208732D3D1D9D9EA440D91621C7A99DB8843C59C1F2E2C7D9B577D512C"  //0C0-0FF
        "166D6F7E1AAD4A774A37447E78FE2021E14A95D112A068ADA019F463C7A55685AABB6888B9246483D18B9C806F474918331782344A4B8531334B26303263D9D2"  //100-13F
        "EB4F4BB99602B352F6AE4046C69A5E7E8E4A18EF9BC0A2DED61310417012FD824CC116CFB7C4C1F7EC7177A17446CBDE96F3EDD88FCD052F0B888A45FDAF2B63"  //140-17F
        "1354F40D16E5FA9C2C4EDA98E798D15E6046DC5363F3096B2C607A9D8DD55B1502A6AC7D3CC8D8C575998E7D796910C804C495235057E91ECD2637C9C1845151"  //180-1BF
        "AC6B9A0490AE3EC6F47740A0DB0BA36D075956CEE7354EA3E9A4F2720B26550C7D394324BC0CB7E9317D8A8661F42191FF10B08256CE3FD25B745E5194906B4D"  //1C0-1FF
        "61CB4C2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //200-23F
        "526F6F74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //240-27F
        "00000001434130303030303030330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //280-2BF
        "000000007BE8EF6CB279C9E2EEE121C6EAF44FF639F88F078B4B77ED9F9560B0358281B50E55AB721115A177703C7A30FE3AE9EF1C60BC1D974676B23A68CC04"  //2C0-2FF
        "B198525BC968F11DE2DB50E4D9E7F071E562DAE2092233E9D363F61DD7C19FF3A4A91E8F6553D471DD7B84B9F1B8CE7335F0F5540563A1EAB83963E09BE90101"  //300-33F
        "1F99546361287020E9CC0DAB487F140D6626A1836D27111F2068DE4772149151CF69C61BA60EF9D949A0F71F5499F2D39AD28C7005348293C431FFBD33F6BCA6"  //340-37F
        "0DC7195EA2BCC56D200BAF6D06D09C41DB8DE9C720154CA4832B69C08C69CD3B073A0063602F462D338061A5EA6C915CD5623579C3EB64CE44EF586D14BAAA88"  //380-3BF
        "34019B3EEBEED3790001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //3C0-3FF
        "00010004969FE8288DA6B9DD52C7BD63642A4A9AE5F053ECCB93613FDA37992087BD9199DA5E6797618D77098133FD5B05CD8288139E2E975CD2608003878CDA"  //400-43F
        "F020F51A0E5B7692780845561B31C61808E8A47C3462224D94F736E9A14E56ACBF71B7F11BBDEE38DDB846D6BD8F0AB4E4948C5434EAF9BF26529B7EB83671D3"  //440-47F
        "CE60A6D7A850DBE6801EC52A7B7A3E5A27BC675BA3C53377CFC372EBCE02062F59F37003AA23AE35D4880E0E4B69F982FB1BAC806C2F75BA29587F2815FD7783"  //480-4BF
        "998C354D52B19E3FAD9FBEF444C48579288DB0978116AFC82CE54DACB9ED7E1BFD50938F22F85EECF3A4F426AE5FEB15B72F022FB36ECCE9314DAD131429BFC9"  //4C0-4FF
        "675F58EE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //500-53F
        "526F6F742D4341303030303030303300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //540-57F
        "00000001585330303030303032300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //580-5BF
        "0000000000000000D21D3CE67C1069DA049D5E5310E76B907E18EEC80B337C4723E339573F4C664907DB2F0832D03DF5EA5F160A4AF24100D71AFAC2E3AE75AF"  //5C0-5FF
        "A1228012A9A21616597DF71EAFCB65941470D1B40F5EF83A597E179FCB5B57C2EE17DA3BC3769864CB47856767229D67328141FC9AB1DF149E0C5C15AEB80BC5"  //600-63F
        "8FC71BE18966642D68308B506934B8EF779F78E4DDF30A0DCF93FCAFBFA131A8839FD641949F47EE25CEECF814D55B0BE6E5677C1EFFEC6F29871EF29AA3ED91"  //640-67F
        "97B0D83852E050908031EF1ABBB5AFC8B3DD937A076FF6761AB362405C3F7D86A3B17A6170A659C16008950F7F5E06A5DE3E5998895EFA7DEEA060BE9575668F"  //680-6BF
        "78AB1907B3BA1B7D0001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"; //6C0-6FF

    size_t certBuf_size = cert.length() / 2;
    char *certBuf = new char[certBuf_size];
    for (size_t i = 0, j = 0; j < certBuf_size; i += 2, j++)
    {
        certBuf[j] = stoi(cert.substr(i, 2), nullptr, 16);
    }

    static const string ticket = 
        "04000100FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"  //000-03F
        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"  //040-07F
        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"  //080-0BF
        "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"  //0C0-0FF
        "FFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //100-13F
        "526F6F742D434130303030303030332D585330303030303032300000000000000000000000000000000000000000000000000000000000000000000000000000"  //140-17F
        "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //180-1BF
        "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //1C0-1FF
        "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //200-23F
        "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"  //240-27F
        "0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C002000000000000"; //280-2BF

    size_t tikBuf_size = ticket.length() / 2;
    char *tikBuf = new char[tikBuf_size];
    for (size_t i = 0, j = 0; j < tikBuf_size; i += 2, j++)
    {
        tikBuf[j] = stoi(ticket.substr(i, 2), nullptr, 16);
    }

    // patch TIK with title data
    memcpy(tikBuf + 0x180, &tkeyh, 8);
    memcpy(tikBuf + 0x188, &tkeyl, 8);
    memcpy(tikBuf + 0x286, &mkey, 1);
    memcpy(tikBuf + 0x2A0, &tid, 8);
    memcpy(tikBuf + 0x2AF, &mkey, 1);

    Result rc = esImportTicket(tikBuf, tikBuf_size, certBuf, certBuf_size);
    return rc;
}

Result installTitle(u64 id)
{
    Result rc = 0;
    rc = nsDownloadApplication(id, 0, g_storageID);
    return rc;
}

bool installTitle(void)
{
    u64 tid = g_titleIDs[g_idselected];
    u8 mkey = g_masterKeys[g_idselected];
    u64 tkeyh = g_titleKeys_high[g_idselected];
    u64 tkeyl = g_titleKeys_low[g_idselected];

    if (R_FAILED(installTikCert(tid, mkey, tkeyh, tkeyl)))
        return false;
    if (R_FAILED(installTitle(tid)))
        return false;
    return true;
}